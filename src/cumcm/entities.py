"""Core domain entities for the smoke jamming optimisation problem."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Iterable, Sequence

import numpy as np

GRAVITY = np.array([0.0, 0.0, -9.8], dtype=float)
SMOKE_FALL_SPEED = np.array([0.0, 0.0, -3.0], dtype=float)


@dataclass(frozen=True)
class Missile:
    """Ballistic missile travelling towards the protected target."""

    init_pos: np.ndarray
    speed: float = 300.0

    def __post_init__(self) -> None:
        object.__setattr__(self, "init_pos", _ensure_vector(self.init_pos))
        direction = -self.init_pos
        norm = np.linalg.norm(direction)
        if norm == 0:
            raise ValueError("Missile initial position cannot be at the origin")
        forward_vector = direction / norm * self.speed
        object.__setattr__(self, "forward_vector", forward_vector)

    def position_at(self, global_t: float) -> np.ndarray:
        """Return the missile position at ``global_t`` seconds."""

        pos = self.init_pos + global_t * self.forward_vector
        if pos[0] < 0:
            raise ValueError("Missile has already passed the target plane")
        return pos


@dataclass(frozen=True)
class TrueGoal:
    """Representation of the protected cylindrical target."""

    bottom_center_pos: np.ndarray
    radius: float = 7.0
    height: float = 10.0

    def __post_init__(self) -> None:
        object.__setattr__(self, "bottom_center_pos",
                           _ensure_vector(self.bottom_center_pos))

    @property
    def top_center_pos(self) -> np.ndarray:
        return self.bottom_center_pos + np.array([0.0, 0.0, self.height])

    def sample_occlusion_points(self) -> Iterable[np.ndarray]:
        """Return characteristic points for occlusion detection."""

        bottom = self.bottom_center_pos
        top = self.top_center_pos
        mid = bottom + np.array([0.0, 0.0, self.height / 2.0])
        offsets = [
            np.array([self.radius, 0.0, 0.0]),
            np.array([-self.radius, 0.0, 0.0]),
            np.array([0.0, self.radius, 0.0]),
            np.array([0.0, -self.radius, 0.0]),
        ]
        for offset in offsets:
            yield bottom + offset
        for offset in offsets:
            yield mid + offset
        for offset in offsets:
            yield top + offset


@dataclass
class Drone:
    """Drone carrying a set of jamming canisters."""

    init_pos: np.ndarray
    forward_vector: np.ndarray

    def __post_init__(self) -> None:
        self.init_pos = _ensure_vector(self.init_pos)
        self.forward_vector = _ensure_vector(self.forward_vector)
        self._validate_speed()

    def _validate_speed(self) -> None:
        speed = self.speed
        if speed < 70.0 or speed > 140.0:
            raise ValueError("The drone's speed must be between 70 and 140 m/s.")

    @property
    def speed(self) -> float:
        return float(np.linalg.norm(self.forward_vector))

    def position_at(self, global_t: float) -> np.ndarray:
        return self.init_pos + global_t * self.forward_vector

    def create_jammer(self, release_delay: float, smoke_release_delay: float) -> "Jammer":
        if release_delay < 0:
            raise ValueError("Release delay must be non-negative")
        if smoke_release_delay < 0:
            raise ValueError("Smoke release delay must be non-negative")
        release_point = self.position_at(release_delay)
        return Jammer(
            release_time=release_delay,
            release_point=release_point,
            forward_vector=self.forward_vector,
            smoke_release_delay=smoke_release_delay,
        )


@dataclass
class Jammer:
    """Jamming canister dropped by a drone."""

    release_time: float
    release_point: np.ndarray
    forward_vector: np.ndarray
    smoke_release_delay: float

    def __post_init__(self) -> None:
        self.release_point = _ensure_vector(self.release_point)
        self.forward_vector = _ensure_vector(self.forward_vector)
        self.smoke_release_delay = float(self.smoke_release_delay)
        self.smoke = Smoke(
            activation_time=self.release_time + self.smoke_release_delay,
            release_point=self.position_at(self.smoke_release_delay),
        )

    def position_at(self, elapsed: float) -> np.ndarray:
        if elapsed < 0:
            raise ValueError("Elapsed time must be non-negative")
        return self.release_point + 0.5 * GRAVITY * elapsed ** 2 + self.forward_vector * elapsed


@dataclass
class Smoke:
    """Smoke cloud generated by a jammer."""

    activation_time: float
    release_point: np.ndarray
    radius: float = 10.0
    duration: float = 20.0
    fall_speed: np.ndarray = field(default_factory=lambda: SMOKE_FALL_SPEED.copy())

    def __post_init__(self) -> None:
        self.release_point = _ensure_vector(self.release_point)
        self.fall_speed = _ensure_vector(self.fall_speed)

    def position_at(self, global_t: float) -> np.ndarray:
        elapsed = global_t - self.activation_time
        if elapsed < 0:
            raise ValueError("Smoke has not been activated yet")
        return self.release_point + elapsed * self.fall_speed

    def is_active(self, global_t: float) -> bool:
        return self.activation_time <= global_t <= self.activation_time + self.duration


def _ensure_vector(values: Sequence[float]) -> np.ndarray:
    arr = np.asarray(values, dtype=float)
    if arr.shape != (3,):
        raise ValueError("Expected a 3D vector")
    return arr
